[
    {
        "Assertional_Logic": "Get_Number_Floor({x: Real}) -> Integer",
        "Lean4_Code": "variable (a: â„)(ha: â„ := âŒŠaâŒ‹)",
        "Explanation": "å‘ä¸‹å–æ•´"
    },
    {
        "Assertional_Logic": "Get_Number_Ceil({x: Real}) -> Integer",
        "Lean4_Code": "variable (a: â„)(ha: â„ := âŒˆaâŒ‰)",
        "Explanation": "å‘ä¸Šå–æ•´"
    },
    {
        "Assertional_Logic": "Get_Number_Round({x: Real}) -> Integer",
        "Lean4_Code": "#check round (3.3: â„)  -- ç»“æœ: 3 #eval round (3.1: â„š)",
        "Explanation": "æœ€æ¥è¿‘çš„æ•´æ•°"
    },
    {
        "Assertional_Logic": "Abs({a: Real}) -> NonNegativeNumbers",
        "Lean4_Code": "def Abs (a : â„) : â„ := |a|",
        "Explanation": "å–açš„ç»å¯¹å€¼"
    },
    {
        "Assertional_Logic": "Log({x: Real}, {y: Real}) -> Real",
        "Lean4_Code": "variable (hl: Real.logb 2 4 = 2)",
        "Explanation": "å–å¯¹æ•°å€¼ Log({2: Real}, {4: Real}) = 2. (Leanä¸­çš„ Real.logb)"
    },
    {
        "Assertional_Logic": "NaturalLog({x: Real}) -> Real",
        "Lean4_Code": "variable (hl: Real.log (exp 1) ^ 2 = 2)",
        "Explanation": "Log(e^2) = 2. (Leanä¸­çš„ Real.log)"
    },
    {
        "Assertional_Logic": "Factorial({x: NaturalNumbers}) -> NaturalNumbers",
        "Lean4_Code": "variable(x: â„•) #check Nat.factorial x",
        "Explanation": "é˜¶ä¹˜ï¼šn! è¡¨ç¤ºä» 1 åˆ° n çš„æ‰€æœ‰æ­£æ•´æ•°çš„ä¹˜ç§¯ã€‚"
    },
    {
        "Assertional_Logic": "Get_Combination({x: NaturalNumbers}, {y: NaturalNumbers}) -> NaturalNumbers",
        "Lean4_Code": "variable(x: â„•)(y: â„•) #check x.choose y",
        "Explanation": "ç»„åˆæ•°ï¼šäºŒé¡¹å¼å®šç†ä¸­çš„ç»„åˆç³»æ•°ï¼Œè®¡ç®— C(n, k) = n! / (k!(n-k)!)ã€‚"
    },
    {
        "Assertional_Logic": "Get_Reciprocal({x: Real}) -> Real",
        "Lean4_Code": "variable(x: â„) #check xâ»Â¹",
        "Explanation": "å€’æ•°ï¼šä¸€ä¸ªæ•°çš„å€’æ•°æ˜¯å…¶ä¸ 1 çš„ä¹˜ç§¯ä¸º 1 çš„æ•°ï¼Œä¾‹å¦‚ 4 çš„å€’æ•°æ˜¯ 1/4ã€‚"
    },
    {
        "Assertional_Logic": "Get_Sum({S: Finset}, {L: LamdaExpression}) -> Real",
        "Lean4_Code": "def Get_Sum (S: Finset â„•)(f: â„• â†’ â„) : â„ := âˆ‘ i âˆˆ S, f i",
        "Explanation": "é›†åˆSå¯ä»¥ä¸º(Set.Icc 1 10).toFinset, lambdaè¡¨è¾¾å¼å¯ä»¥ä¸º(Î» x : â„• => x ^ 2 + 1); æ±‚é›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„å’Œ"
    },
    {
        "Assertional_Logic": "Get_Prod({S: Finset}, {L: LamdaExpression}) -> â„",
        "Lean4_Code": "def Get_Prod (S: Finset â„•)(f: â„• â†’ â„) : â„ := âˆ i âˆˆ S, f i",
        "Explanation": "é›†åˆSå¯ä»¥ä¸º(Set.Icc 1 10).toFinset, lambdaè¡¨è¾¾å¼å¯ä»¥ä¸º(Î» x : â„• => x ^ 2 + 1); æ±‚é›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯"
    },
    {
        "Assertional_Logic": "Exp({x: Real}) -> Real",
        "Lean4_Code": "variable (x: â„) #check exp 2",
        "Explanation": "æŒ‡æ•°å‡½æ•°ï¼šè®¡ç®— e^xï¼Œå…¶ä¸­ e ä¸ºè‡ªç„¶å¯¹æ•°çš„åº•æ•°ã€‚"
    },
    {
        "Assertional_Logic": "Get_PolyDegree(x: Polynomial) -> Number",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check p.degree\n#check p.natDegree",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›å®ƒçš„æœ€é«˜æ¬¡å¹‚"
    },
    {
        "Assertional_Logic": "Get_Polyroots(x: Polynomial) -> Set",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check p.roots",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›å®ƒçš„æ ¹çš„é›†åˆ"
    },
    {
        "Assertional_Logic": "Get_Term_Coefficient(x: Polynomial, y: PolynomialTerm) -> Number",
        "Lean4_Code": "variable (p : Polynomial â„)(n : â„•)\n#check p.coeff n",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼å’Œå¯¹åº”çš„æŸä¸€é¡¹, è¿”å›è¯¥é¡¹çš„ç³»æ•°"
    },
    {
        "Assertional_Logic": "Get_PolyTerm(x: Polynomial) -> Set",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check (monomial 2 (p.coeff 2))",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›å®ƒçš„é¡¹çš„é›†åˆ"
    },
    {
        "Assertional_Logic": "Get_ConstantTerm(x: Polynomial) -> Number",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check p.coeff 0",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›å®ƒçš„å¸¸æ•°é¡¹"
    },
    {
        "Assertional_Logic": "Is_PolyFactor(A: Polynomial, B: Polynomial) -> Boolean",
        "Lean4_Code": "variable (p q : Polynomial â„)\n#check p âˆ£ q",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªå¤šé¡¹å¼, åˆ¤æ–­ A æ˜¯ä¸æ˜¯ B çš„å› å­"
    },
    {
        "Assertional_Logic": "Is_IrreduciblePolynomial(A: Polynomial) -> Boolean",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check Irreducible p",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, åˆ¤æ–­æ˜¯å¦å¯çº¦"
    },
    {
        "Assertional_Logic": "Get_PolyCoefficient(x: Polynomial) -> Set",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check p.coeffs",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›å®ƒçš„ç³»æ•°é›†åˆ"
    },
    {
        "Assertional_Logic": "Eval_Value_Polynomial(P: Polynomial(a), x: Prop(a)) -> Number",
        "Lean4_Code": "variable (p : Polynomial â„) (x : â„)\n#check eval 10 p",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼å’Œå˜é‡åœ¨æŸå¤„çš„å€¼, è¿”å›å¯¹åº”çš„å€¼"
    },
    {
        "Assertional_Logic": "Solve_equation(x: Variable, P: Equation) -> Set",
        "Lean4_Code": "theorem Solve_equation : {x :â„ | x + 1 = 0 } = sorry := by sorry",
        "Explanation": "è¾“å…¥ä¸€ä¸ªç­‰å¼å’Œå¯¹åº”å˜é‡, è¿”å›è§£é›†(å¯æ‰©å±•åˆ°å¤šå…ƒ, ä½†æ–¹ç¨‹ä¸ªæ•°å¿…é¡»ç­‰äºå˜é‡æ•°)"
    },
    {
        "Assertional_Logic": "Solve_inequation(x: Variable, P: Inequation) -> Set",
        "Lean4_Code": "theorem Solve_inequation : {x :â„ | x + 1 > 0 } = sorry := by sorry",
        "Explanation": "è¾“å…¥ä¸€ä¸ªä¸ç­‰å¼å’Œå¯¹åº”å˜é‡, è¿”å›è§£é›† (å¯æ‰©å±•åˆ°å¤šå…ƒ, ä½†æ–¹ç¨‹ä¸ªæ•°å¿…é¡»ç­‰äºå˜é‡æ•°)"
    },
    {
        "Assertional_Logic": "Is_Polynomial_Root(P: Polynomial, x: Variable) -> Boolean",
        "Lean4_Code": "variable (p : Polynomial â„) (a : â„)\n#check IsRoot p a",
        "Explanation": "åˆ¤æ–­ x æ˜¯ä¸æ˜¯å¤šé¡¹å¼ P çš„æ ¹"
    },
    {
        "Assertional_Logic": "Get_Polynomial_Composition(f: Polynomial, g: Polynomial) -> Polynomial",
        "Lean4_Code": "variable (f g : Polynomial â„)\n#check comp f g",
        "Explanation": "è®¡ç®—å¤šé¡¹å¼çš„å¤åˆ"
    },
    {
        "Assertional_Logic": "Get_Polynomial_Leading_Coefficient(x: Polynomial) -> Number",
        "Lean4_Code": "variable (p : Polynomial â„)\n#check p.leadingCoeff",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå¤šé¡¹å¼, è¿”å›æœ€é«˜é¡¹ç³»æ•°"
    },
    {
        "Assertional_Logic": "Get_Sequence_Terms(s: Sequence, n: Integers) -> Numbers",
        "Lean4_Code": "variable (seq: â„• â†’ â„) \n #check seq 10",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæ•°åˆ—å’Œä¸€ä¸ªç´¢å¼•ï¼Œè¿”å›å¯¹åº”çš„é¡¹"
    },
    {
        "Assertional_Logic": "Get_Sequences_Sum(s: Sequence, i: Integer) -> Number",
        "Lean4_Code": "def Get_Sequences_Sum (s : â„• â†’ â„) (i : â„•) : â„ :=\n  âˆ‘ n âˆˆ Finset.Icc 1 i, s n \n#check Get_Sequences_Sum seq 10",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæ•°åˆ—å’Œä¸€ä¸ªç´¢å¼•ï¼Œè¿”å›ä» 1 åˆ° i å¤„çš„éƒ¨åˆ†å’Œ"
    },
    {
        "Assertional_Logic": "Is_ArithmeticSequence(s: Sequence) -> Boolean",
        "Lean4_Code": "def Is_ArithmeticSequence (s : â„• â†’ â„) : Prop :=\n  âˆƒ d : â„, âˆ€ n : â„•, s (n + 1) - s n = d \n#check Is_ArithmeticSequence fib",
        "Explanation": "åˆ¤æ–­æ•°åˆ—æ˜¯å¦ä¸ºç­‰å·®æ•°åˆ—"
    },
    {
        "Assertional_Logic": "Is_GeometricSequence(s: Sequence) -> Boolean",
        "Lean4_Code": "def Is_GeometricSequence (s : â„• â†’ â„) : Prop :=\n  âˆƒ q : â„, âˆ€ n : â„•, s (n + 1) / s n = q \n#check Is_GeometricSequence fib",
        "Explanation": "åˆ¤æ–­æ•°åˆ—æ˜¯å¦ä¸ºç­‰æ¯”æ•°åˆ—"
    },
    {
        "Assertional_Logic": "Is_MonotonicSequence(s: Sequence) -> Boolean",
        "Lean4_Code": "def Is_MonotonicSequence (s : â„• â†’ â„) : Prop := \n  Monotone s âˆ¨ Antitone s \n#check Is_MonotonicSequence seq",
        "Explanation": "åˆ¤æ–­æ•°åˆ—æ˜¯å¦ä¸ºå•è°ƒæ•°åˆ—"
    },
    {
        "Assertional_Logic": "Get_CommonDifference(s: ArithmeticSequence) -> Number",
        "Lean4_Code": "structure ArithmeticSequence where\n(Sequence: â„• â†’ â„)\n(d : â„) -- å…¬å·®\n(property : âˆ€ n : â„•, Sequence (n + 1) - Sequence n = d)\nvariable (S: ArithmeticSequence) \n #check S.d",
        "Explanation": "è¾“å…¥ä¸€ä¸ªç­‰å·®æ•°åˆ—ï¼Œè¿”å›å…¬å·®"
    },
    {
        "Assertional_Logic": "Get_CommonRatio(s: GeometricSequence) -> Number",
        "Lean4_Code": "structure GeometricSequence where \n(Sequence: â„• â†’ â„)\n(q : â„) -- å…¬æ¯”\n(property : âˆ€ n : â„•, Sequence (n + 1) / Sequence n = q)  -- ç¡®ä¿æ˜¯ç­‰æ¯”æ•°åˆ— \n variable (S: GeometricSequence) \n #check S.q",
        "Explanation": "è¾“å…¥ä¸€ä¸ªç­‰æ¯”æ•°åˆ—ï¼Œè¿”å›å…¬æ¯”"
    },
    {
        "Assertional_Logic": "Is_Monotonic_Increasing_Sequence(s: Sequence) -> Boolean",
        "Lean4_Code": "#check StrictMonoOn seq",
        "Explanation": "åˆ¤æ–­æ•°åˆ—æ˜¯å¦ä¸ºä¸¥æ ¼å•è°ƒé€’å¢"
    },
    {
        "Assertional_Logic": "Is_Monotonic_Decreasing_Sequence(s: Sequence) -> Boolean",
        "Lean4_Code": "#check StrictAntiOn seq",
        "Explanation": "åˆ¤æ–­æ•°åˆ—æ˜¯å¦ä¸ºä¸¥æ ¼å•è°ƒé€’å‡"
    },
    {
        "Assertional_Logic": "Get_FiniteSequences_Length(s: FiniteSequence) -> PositiveInteger",
        "Lean4_Code": "structure FiniteSequence  where\n  (Sequence: â„• â†’ â„)\n  (length: â„•)\n#check hp\n#check hp.length",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæœ‰é™æ•°åˆ—ï¼Œè¿”å›å…¶é•¿åº¦"
    },
    {
        "Assertional_Logic": "Get_Function_Range(f: Function) -> Set",
        "Lean4_Code": "#check Set.range f",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›å…¶å€¼åŸŸ"
    },
    {
        "Assertional_Logic": "Get_Function_Maximum(f: Function) -> Number",
        "Lean4_Code": "def Get_Function_Maximum  (f: â„• â†’ â„•): sSup (Set.range f)= 100 :=by\n  sorry",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›å…¶æœ€å¤§å€¼"
    },
    {
        "Assertional_Logic": "Get_Function_Minimum(f: Function) -> Number",
        "Lean4_Code": "def Get_Function_Minimum  (f: â„• â†’ â„•): sInf (Set.range f)= 100 :=by\n  sorry",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›å…¶æœ€å°å€¼"
    },
    {
        "Assertional_Logic": "Get_Function_Zeroes(f: Function) -> Set",
        "Lean4_Code": "def Is_Function_Root (f : â„ â†’ â„) (x : â„) : Prop := f x = 0\n#check Is_Function_Root f1 3\ndef Get_Function_Zeroes (f: â„ â†’ â„): Set â„ := { x | Is_Function_Root f x}\n#check Get_Function_Zeroes f1",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›å…¶é›¶ç‚¹é›†åˆ"
    },
    {
        "Assertional_Logic": "Get_Function_Composition(f: Function, g: Function) -> Function",
        "Lean4_Code": "#check f1 âˆ˜ f2",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªå‡½æ•°ï¼Œè¿”å›å®ƒä»¬çš„å¤åˆ"
    },
    {
        "Assertional_Logic": "Get_Function_Minimalperiod(f: Function) -> Real",
        "Lean4_Code": "def is_periodic_real (f : â„ â†’ â„) (T : â„) : Prop :=\n  âˆ€ x, f (x + T) = f x\n\nnoncomputable def least_positive_period_real (f : â„ â†’ â„) : â„ :=\n  sInf {T: â„ | T > 0 âˆ§ is_periodic_real f T}",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‘¨æœŸå‡½æ•°ï¼Œè¿”å›å…¶æœ€å°æ­£å‘¨æœŸ"
    },
    {
        "Assertional_Logic": "Get_Inverse_Function(f: Function) -> Function",
        "Lean4_Code": "#check Function.invFun f1\n#check f1â»Â¹",
        "Explanation": "è¾“å…¥ä¸€ä¸ªåŒå°„å‡½æ•°ï¼Œè¿”å›å…¶åå‡½æ•°"
    },
    {
        "Assertional_Logic": "Get_Function_IthComposition(f: Function, i: Integer) -> Function",
        "Lean4_Code": "#check f1^[3]",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªæ•´æ•° iï¼Œè¿”å›å‡½æ•°çš„ i æ¬¡å¤åˆ"
    },
    {
        "Assertional_Logic": "Get_Function_Value(f: Function, x: Number) -> Number",
        "Lean4_Code": "#check f 10",
        "Explanation": "è¾“å…¥ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªæ•° xï¼Œè¿”å› f(x)"
    },
    {
        "Assertional_Logic": "Is_Bijection(f: Function) -> Boolean",
        "Lean4_Code": "#check Function.Bijective f1",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªå‡½æ•°æ˜¯å¦æ˜¯åŒå°„"
    },
    {
        "Assertional_Logic": "Is_Injection(f: Function) -> Boolean",
        "Lean4_Code": "#check Function.Injective f1",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªå‡½æ•°æ˜¯å¦æ˜¯å•å°„"
    },
    {
        "Assertional_Logic": "Is_Surjection(f: Function) -> Boolean",
        "Lean4_Code": "#check Function.Surjective f1",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªå‡½æ•°æ˜¯å¦æ˜¯æ»¡å°„"
    },
    {
        "Assertional_Logic": "Get_QuadraticFunction_Discriminant(f: QuadraticFunction) -> Real",
        "Lean4_Code": "variable(A: QuadraticFunction)\n#check A.discriminant",
        "Explanation": "è¾“å…¥ä¸€ä¸ªäºŒæ¬¡å‡½æ•°ï¼Œè¿”å›å…¶åˆ¤åˆ«å¼"
    },
    {
        "Assertional_Logic": "Get_StepFunction_Expression(f: Function, P: Proposition) -> Expression",
        "Lean4_Code": "theorem TestStepFunction (f1: â„• â†’ â„•)(h: âˆ€ x > 2, f1 x = x^2 + 1): f1 3 = 10:= by\n  have h' : 3 > 2 :=by norm_num\n  exact h 3 h'",
        "Explanation": "è¾“å…¥ä¸€ä¸ªåˆ†æ®µå‡½æ•°å’Œä¸€ä¸ªå‘½é¢˜ï¼Œè¿”å›å‡½æ•°çš„è¡¨è¾¾å¼"
    },
    {
        "Assertional_Logic": "Set_Union(A: Set, B: Set) -> Set",
        "Lean4_Code": "#check a1 âˆª a2",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªé›†åˆï¼Œè¿”å›å®ƒä»¬çš„å¹¶é›†"
    },
    {
        "Assertional_Logic": "Set_Intersection(A: Set, B: Set) -> Set",
        "Lean4_Code": "#check a1 âˆ© a2",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªé›†åˆï¼Œè¿”å›å®ƒä»¬çš„äº¤é›†"
    },
    {
        "Assertional_Logic": "Set_Difference(A: Set, B: Set) -> Set",
        "Lean4_Code": "#check a1.diff a2\n#check a1 \\ a2",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªé›†åˆï¼Œè¿”å›å®ƒä»¬çš„å·®é›†"
    },
    {
        "Assertional_Logic": "Set_SymmetricDifference(A: Set, B: Set) -> Set",
        "Lean4_Code": "#check symmDiff a1 a2",
        "Explanation": "è¾“å…¥ä¸¤ä¸ªé›†åˆï¼Œè¿”å›å®ƒä»¬çš„å¯¹ç§°å·®é›†"
    },
    {
        "Assertional_Logic": "Set_Subset(A: Set, B: Set) -> Boolean",
        "Lean4_Code": "#check a1 âŠ† a2",
        "Explanation": "åˆ¤æ–­é›†åˆ A æ˜¯å¦æ˜¯é›†åˆ B çš„å­é›†"
    },
    {
        "Assertional_Logic": "Set_ProperSubset(A: Set, B: Set) -> Boolean",
        "Lean4_Code": "#check a1 âŠ‚ a2",
        "Explanation": "åˆ¤æ–­é›†åˆ A æ˜¯å¦æ˜¯é›†åˆ B çš„çœŸå­é›†"
    },
    {
        "Assertional_Logic": "Set_Superset(A: Set, B: Set) -> Boolean",
        "Lean4_Code": "#check a1 âŠ‡ a2",
        "Explanation": "åˆ¤æ–­é›†åˆ A æ˜¯å¦æ˜¯é›†åˆ B çš„è¶…é›†"
    },
    {
        "Assertional_Logic": "Set_ProperSuperset(A: Set, B: Set) -> Boolean",
        "Lean4_Code": "#check a1 âŠƒ a2",
        "Explanation": "åˆ¤æ–­é›†åˆ A æ˜¯å¦æ˜¯é›†åˆ B çš„çœŸè¶…é›†"
    },
    {
        "Assertional_Logic": "Set_Cardinality(A: Set) -> Number",
        "Lean4_Code": "variable (S: Finset â„•)(H: S.Nonempty)\n#check S.card\nvariable (S: Set â„)[Fintype S]\n#check S.toFinset.card",
        "Explanation": "è¾“å…¥ä¸€ä¸ªé›†åˆï¼Œè¿”å›å…¶åŸºæ•°ï¼ˆå…ƒç´ ä¸ªæ•°ï¼‰"
    },
    {
        "Assertional_Logic": "Set_PowerSet(A: Set) -> Set",
        "Lean4_Code": "#check ğ’« a1",
        "Explanation": "è¾“å…¥ä¸€ä¸ªé›†åˆï¼Œè¿”å›å…¶å¹‚é›†"
    },
    {
        "Assertional_Logic": "Set_Complement(A: Set, U: Set) -> Set",
        "Lean4_Code": "#check a1á¶œ",
        "Explanation": "è¾“å…¥ä¸€ä¸ªé›†åˆ A å’Œå…¨é›† Uï¼Œè¿”å› A åœ¨ U ä¸­çš„è¡¥é›†"
    },
    {
        "Assertional_Logic": "Set_Equality(A: Set, B: Set) -> Boolean",
        "Lean4_Code": "#check a1 = a2",
        "Explanation": "åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦ç›¸ç­‰"
    },
    {
        "Assertional_Logic": "Get_Set_Sum(A: Set) -> Real",
        "Lean4_Code": "#check âˆ‘ i âˆˆ S, i",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæœ‰é™é›†åˆï¼Œè¿”å›å…¶æ‰€æœ‰å…ƒç´ çš„å’Œ"
    },
    {
        "Assertional_Logic": "Get_Set_Product(A: Set) -> Real",
        "Lean4_Code": "#check âˆ i âˆˆ S, i",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæœ‰é™é›†åˆï¼Œè¿”å›å…¶æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯"
    },
    {
        "Assertional_Logic": "Build_Set(x: VariableType, P(x): Proposition) -> Set",
        "Lean4_Code": "#check {a : â„• | a > 2}",
        "Explanation": "æ ¹æ®ç»™å®šçš„æ¡ä»¶ P(x) æ„é€ ä¸€ä¸ªé›†åˆ"
    },
    {
        "Assertional_Logic": "Get_Set_Maximum(A: Set) -> Real",
        "Lean4_Code": "#check sSup a1",
        "Explanation": "è¾“å…¥ä¸€ä¸ªé›†åˆï¼Œè¿”å›å…¶æœ€å¤§å…ƒç´ "
    },
    {
        "Assertional_Logic": "Get_Set_Minimum(A: Set) -> Real",
        "Lean4_Code": "#check sInf a1",
        "Explanation": "è¾“å…¥ä¸€ä¸ªé›†åˆï¼Œè¿”å›å…¶æœ€å°å…ƒç´ "
    },
    {
        "Assertional_Logic": "Elements_In_Set(A: Individual, B: Set) -> Boolean",
        "Lean4_Code": "#check e âˆˆ se",
        "Explanation": "åˆ¤æ–­å…ƒç´  A æ˜¯å¦å±äºé›†åˆ B"
    },
    {
        "Assertional_Logic": "Get_Set_Means(A: Set) -> Real",
        "Lean4_Code": "def Get_Set_Means (s : Set â„•) [Fintype â†‘s] : â„• :=\n  (âˆ‘ i âˆˆ s, i )/(s.toFinset.card)",
        "Explanation": "è¾“å…¥ä¸€ä¸ªæœ‰é™é›†åˆï¼Œè¿”å›å…¶å‡å€¼"
    },
    {
        "Assertional_Logic": "Is_Set_BoundedFromAbove(A: Set) -> Boolean",
        "Lean4_Code": "#check Set.Bounded Nat.le a1",
        "Explanation": "åˆ¤æ–­é›†åˆæ˜¯å¦æœ‰ä¸Šç•Œ"
    },
    {
        "Assertional_Logic": "Is_Set_Unbounded(A: Set) -> Boolean",
        "Lean4_Code": "#check Set.Unbounded Nat.le a1",
        "Explanation": "åˆ¤æ–­é›†åˆæ˜¯å¦æ— ç•Œ"
    },
    {
        "Assertional_Logic": "Get_UniversalSet(A: Concept) -> Set",
        "Lean4_Code": "def u : Set â„• :=  Set.univ",
        "Explanation": "å®šä¹‰å…¨é›†ï¼Œå³åŒ…å«æ‰€æœ‰ç›¸å…³å…ƒç´ çš„é›†åˆ"
    },
    {
        "Assertional_Logic": "Range(a: NaturalNumber, b: NaturalNumber) -> FiniteSet",
        "Lean4_Code": "def Range (a b : â„•) : Finset â„• := Finset.Icc a b",
        "Explanation": "å®šä¹‰ä¸€ä¸ªåŒ…å« a åˆ° b ä¹‹é—´æ‰€æœ‰æ•´æ•°çš„æœ‰é™é›†åˆ"
    },
    {
        "Assertional_Logic": "Get_Open_Interval(a: Number, b: Number) -> Interval",
        "Lean4_Code": "#check Set.Ioo a b",
        "Explanation": "è·å–å¼€åŒºé—´ (a, b)ï¼Œä¸åŒ…å«ç«¯ç‚¹ a å’Œ b"
    },
    {
        "Assertional_Logic": "Get_LeftClosedRightOpen_Interval(a: Number, b: Number) -> Interval",
        "Lean4_Code": "#check Set.Ico a b",
        "Explanation": "è·å–å·¦é—­å³å¼€åŒºé—´ [a, b)ï¼ŒåŒ…å« a ä½†ä¸åŒ…å« b"
    },
    {
        "Assertional_Logic": "Get_LeftOpenRightClosed_Interval(a: Number, b: Number) -> Interval",
        "Lean4_Code": "#check Set.Ioc a b",
        "Explanation": "è·å–å·¦å¼€å³é—­åŒºé—´ (a, b]ï¼ŒåŒ…å« b ä½†ä¸åŒ…å« a"
    },
    {
        "Assertional_Logic": "Get_Closed_Interval(a: Number, b: Number) -> Interval",
        "Lean4_Code": "#check Set.Icc a b",
        "Explanation": "è·å–é—­åŒºé—´ [a, b]ï¼ŒåŒ…å« a å’Œ b"
    },
    {
        "Assertional_Logic": "Get_RightOpen_Interval(b: Number) -> Interval",
        "Lean4_Code": "#check Set.Iio b",
        "Explanation": "è·å–å³å¼€åŒºé—´ (-âˆ, b)ï¼ŒåŒ…å«æ‰€æœ‰å°äº b çš„æ•°"
    },
    {
        "Assertional_Logic": "Get_RightClosed_Interval(b: Number) -> Interval",
        "Lean4_Code": "#check Set.Iic b",
        "Explanation": "è·å–å³é—­åŒºé—´ (-âˆ, b]ï¼ŒåŒ…å«æ‰€æœ‰å°äºç­‰äº b çš„æ•°"
    },
    {
        "Assertional_Logic": "Get_LeftOpen_Interval(a: Number) -> Interval",
        "Lean4_Code": "#check Set.Ioi a",
        "Explanation": "è·å–å·¦å¼€åŒºé—´ (a, +âˆ)ï¼ŒåŒ…å«æ‰€æœ‰å¤§äº a çš„æ•°"
    },
    {
        "Assertional_Logic": "Get_LeftClosed_Interval(a: Number) -> Interval",
        "Lean4_Code": "#check Set.Ici a",
        "Explanation": "è·å–å·¦é—­åŒºé—´ [a, +âˆ)ï¼ŒåŒ…å«æ‰€æœ‰å¤§äºç­‰äº a çš„æ•°"
    },
    {
        "Assertional_Logic": "Get_Digit: [(Optional)Base: NaturalNumber](n: NaturalNumber) -> List",
        "Lean4_Code": "#check Nat.digits 10 100",
        "Explanation": "è·å–ä¸€ä¸ªæ•°çš„å„ä½æ•°ï¼Œé»˜è®¤åŸºæ•°ä¸º10"
      },
      {
        "Assertional_Logic": "Covert_Digit_To_Number: [(Optional)Base: NaturalNumber](L: List) -> NaturalNumber",
        "Lean4_Code": "#check Nat.ofDigits 10 [0, 0, 1]",
        "Explanation": "å°†ä¸€ä¸ªListï¼ˆå„ä½æ•°ï¼‰è½¬åˆ°ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œé»˜è®¤åŸºæ•°ä¸º10"
      },
      {
        "Assertional_Logic": "Get_DigitCount: Get_DigitCount[(Optional)Base: NaturalNumber](n: Integer) -> Integer",
        "Lean4_Code": "#check (Nat.digits 10 100).length",
        "Explanation": "è·å–ä¸€ä¸ªæ•°çš„æ•°å­—ä¸ªæ•°"
      },
      {
        "Assertional_Logic": "Get_DigitProduct: [(Optional)Base: NaturalNumber]Get_DigitProduct(n: Integer) -> Integer",
        "Lean4_Code": "def Get_DigitProduct(L: List â„•): â„• := List.foldl (Î» (x:â„•) (y:â„•) => x * y) 1 L",
        "Explanation": "è·å–ä¸€ä¸ªæ•°çš„æ•°å­—ç§¯"
      },
      {
        "Assertional_Logic": "Get_DigitSum: [(Optional)Base: NaturalNumber]Get_DigitSum(n: Integer) -> Integer",
        "Lean4_Code": "def Get_DigitSum(L: List â„•): â„• := List.foldl (Î» (x:â„•) (y:â„•) => x + y) 0 L",
        "Explanation": "è·å–ä¸€ä¸ªæ•°çš„æ•°å­—å’Œ"
      },
      {
        "Assertional_Logic": "Is_PandigitalNumber: Is_PandigitalNumber(L: List) -> Boolean",
        "Lean4_Code": "def Is_PandigitalNumber (L: List â„•) : Prop := (âˆ€ d : â„•, d âˆˆ (Finset.range 10) â†’ d âˆˆ L)",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºå…¨æ•°å­—"
      },
      {
        "Assertional_Logic": "Is_PalindromeNumber: Is_PalindromeNumber(L: List) -> Boolean",
        "Lean4_Code": "#check (Nat.digits 10 101).Palindrome",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºå›æ–‡æ•°"
      },
      {
        "Assertional_Logic": "Get_Ones_Digit: [(Optional)Base: NaturalNumber]Get_Ones_Digit({n: Integer}) -> Integer",
        "Lean4_Code": "def convert_base_eval (n : â„•) (b1 b2 : â„•) : â„• := Nat.ofDigits b2 (Nat.digits b1 n)",
        "Explanation": "è·å–ä¸€ä¸ªæ•°çš„æœ€åä¸€ä½æ•°å­—"
      },
      {
        "Assertional_Logic": "Is_Nat_Mod: Is_Nat_Mod(a: NaturalNumber, b: NaturalNumber, n: NaturalNumber) -> Boolean",
        "Lean4_Code": "def Is_Nat_Mod (a b n : â„•) : Prop := a â‰¡ b [MOD n]",
        "Explanation": "æ£€æŸ¥ a å’Œ b å¯¹æ¨¡ n æ˜¯å¦ç­‰ä»·"
      },
      {
        "Assertional_Logic": "Get_InverseMod: Get_InverseMod(a: NaturalNumber, m: NaturalNumber) -> Boolean",
        "Lean4_Code": "def Is_InverseMod (a m : â„•) : Prop := âˆƒ x : â„•, Is_Nat_Mod (a * x) 1 m",
        "Explanation": "åˆ¤æ–­ a æ˜¯å¦æœ‰é€†å…ƒæ¨¡ m"
      },
      {
        "Assertional_Logic": "Get_FractionalPart: Get_FractionalPart(x: Real) -> Real",
        "Lean4_Code": "#check Int.fract x",
        "Explanation": "è·å–å®æ•° x çš„å°æ•°éƒ¨åˆ†"
      },
      {
        "Assertional_Logic": "Get_IntegerPart: Get_IntegerPart(x: Real) -> Integer",
        "Lean4_Code": "#check Int.floor x",
        "Explanation": "è·å–å®æ•° x çš„æ•´æ•°éƒ¨åˆ†"
      },
      {
        "Assertional_Logic": "Get_LeastCommonDenominator: Get_LeastCommonDenominator(f1: RationalNumbers, f2: RationalNumbers) -> Integer",
        "Lean4_Code": "def Get_LeastCommonDenominator(q1: â„š)(q2: â„š): â„• := Nat.lcm q1.den q2.den",
        "Explanation": "è·å–ä¸¤ä¸ªåˆ†æ•°çš„æœ€å°å…¬åˆ†æ¯"
      },
      {
        "Assertional_Logic": "Get_Mediant: Get_Mediant(q1: RationalNumbers, q2: RationalNumbers) -> RationalNumbers",
        "Lean4_Code": "def Get_Mediant(q1: â„š)(q2: â„š): â„¤ := (q1.num + q2.num) / (q1.den + q2.den)",
        "Explanation": "è·å–ä¸¤ä¸ªæœ‰ç†æ•°çš„ä¸­å€¼"
      },
      {
        "Assertional_Logic": "UnitFraction: UnitFraction(q: RationalNumbers) -> Prop",
        "Lean4_Code": "def Is_UnitFraction(q: â„š): Prop := (q.num = 1) âˆ§ (q.den > 0)",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæœ‰ç†æ•°æ˜¯å¦ä¸ºå•ä½åˆ†æ•°"
      },
      {
        "Assertional_Logic": "Is_ProperFraction: Is_ProperFraction(q: RationalNumbers) -> Prop",
        "Lean4_Code": "def Is_ProperFraction(q: â„š): Prop := q.num < q.den",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæœ‰ç†æ•°æ˜¯å¦ä¸ºçœŸåˆ†æ•°"
      },
      {
        "Assertional_Logic": "Is_IrreducibleFraction: Is_IrreducibleFraction(q: RationalNumbers) -> Prop",
        "Lean4_Code": "def Is_IrreducibleFraction(q: â„š): Prop := Int.gcd q.num q.den = 1",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæœ‰ç†æ•°æ˜¯å¦ä¸ºæœ€ç®€åˆ†æ•°"
      },
      {
        "Assertional_Logic": "Is_Coprime: Is_Coprime(m: NaturalNumber, n: NaturalNumber) -> Prop",
        "Lean4_Code": "#check Nat.Coprime 10 20",
        "Explanation": "åˆ¤æ–­ä¸¤ä¸ªè‡ªç„¶æ•°æ˜¯å¦äº’è´¨"
      },
      {
        "Assertional_Logic": "Is_Factor: Is_Factor(a: NaturalNumber, b: NaturalNumber) -> Prop",
        "Lean4_Code": "#eval 2 âˆ£ 10",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªè‡ªç„¶æ•°æ˜¯å¦ä¸ºå¦ä¸€ä¸ªè‡ªç„¶æ•°çš„å› æ•°"
      },
      {
        "Assertional_Logic": "Get_GCD: Get_GCD(a: NaturalNumber, b: NaturalNumber) -> NaturalNumber",
        "Lean4_Code": "#eval Nat.gcd 10 15",
        "Explanation": "è®¡ç®—ä¸¤ä¸ªè‡ªç„¶æ•°çš„æœ€å¤§å…¬çº¦æ•°"
      },
      {
        "Assertional_Logic": "Get_LCM: Get_LCM(a: NaturalNumber, b: NaturalNumber) -> NaturalNumber",
        "Lean4_Code": "#eval Nat.lcm 2 10",
        "Explanation": "è®¡ç®—ä¸¤ä¸ªè‡ªç„¶æ•°çš„æœ€å°å…¬å€æ•°"
      },
      {
        "Assertional_Logic": "Is_PerfectSquare: Is_PerfectSquare(a: NaturalNumber) -> Prop",
        "Lean4_Code": "def Is_PerfectSquare(a: â„•): Prop := IsSquare a",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªè‡ªç„¶æ•°æ˜¯å¦æ˜¯å®Œå…¨å¹³æ–¹æ•°"
      },
      {
        "Assertional_Logic": "Get_Remainder: Get_Remainder(a: NaturalNumber, b: NaturalNumber) -> NaturalNumber",
        "Lean4_Code": "#eval 7 % 3",
        "Explanation": "è®¡ç®— a é™¤ä»¥ b çš„ä½™æ•°"
      },
      {
        "Assertional_Logic": "Is_Prime: Is_Prime(a: NaturalNumber) -> Prop",
        "Lean4_Code": "#check (Prime 10)",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªè‡ªç„¶æ•°æ˜¯å¦ä¸ºç´ æ•°"
      },
      {
        "Assertional_Logic": "Get_SumOfSquares: Get_SumOfSquares(n: Integer) -> Integer",
        "Lean4_Code": "def Get_SumOfSquares(n: â„•): â„• := âˆ‘ i âˆˆ Set.Icc 1 n, i ^ 2",
        "Explanation": "è®¡ç®—ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹å’Œ"
      },
      {
        "Assertional_Logic": "Is_Twin_Prime: Is_Twin_Prime(p: Prime) -> Boolean",
        "Lean4_Code": "def Is_Twin_Prime(n: â„•): Prop := Prime n âˆ§ (Prime (n + 2) âˆ¨ Prime (n - 2))",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªç´ æ•°æ˜¯å¦ä¸ºåŒèƒèƒç´ æ•°"
      },
      {
        "Assertional_Logic": "Is_Factorial_Prime: Is_Factorial_Prime(p: Prime) -> Boolean",
        "Lean4_Code": "def Is_Factorial_Prime(N: â„•): Prop := Prime N âˆ§ (âˆƒ n, N = Nat.factorial n + 1 âˆ¨ N = Nat.factorial n - 1)",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªç´ æ•°æ˜¯å¦æ˜¯é˜¶ä¹˜ç´ æ•°ï¼Œå³æ˜¯å¦å¯ä»¥è¡¨ç¤ºä¸ºæŸä¸ªé˜¶ä¹˜åŠ 1æˆ–å‡1"
      },
      {
        "Assertional_Logic": "Is_MersenneNumber: Is_MersenneNumber(N: NaturalNumber) -> Boolean",
        "Lean4_Code": "def Is_MersenneNumber(N: â„•): Prop := âˆƒ n, N = 2 ^ n -1",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºæ¢…æ£®æ•°ï¼Œå³æ˜¯å¦å¯ä»¥è¡¨ç¤ºä¸º 2^n - 1"
      },
      {
        "Assertional_Logic": "Is_SinglyEvenNumber: Is_SinglyEvenNumber(N: NaturalNumber) -> Boolean",
        "Lean4_Code": "def Is_SinglyEvenNumber(N: â„•): Prop := 2 âˆ£ N âˆ§ Â¬ (4 âˆ£ N)",
        "Explanation": "åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºå¥‡å¶æ•°ï¼Œå³è¢«2æ•´é™¤ä½†ä¸èƒ½è¢«4æ•´é™¤"
      },
      {
        "Assertional_Logic": "Order: Order(a: NaturalNumber, N: NaturalNumber) -> Number",
        "Lean4_Code": "def orderOf (a : â„•) (N : â„•) : â„• := nat.orderOf a N",
        "Explanation": "è®¡ç®—ä¸€ä¸ªæ•° a åœ¨æ¨¡ N ç¾¤ä½“ä¸­çš„é˜¶ï¼Œå³æœ€å°çš„æ­£æ•´æ•° k ä½¿å¾— a^k â‰¡ 1 (mod N)"
      }
]